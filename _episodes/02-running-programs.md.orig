---
title: "Running programs using the shell"
teaching: 15
exercises: 15
objectives:
- "Understand file and folder permissions"
- "Learn how to run a program using the shell"
- "Learn to redirect the output of a program to a file, or to another program"
questions:
- "How can I run a program from the shell?"
- "How can I save the result of a program?"
- "How can I combine programs together?"
keypoints:
- "All files and folders have an owner (a user) and a group (a collection of users) associated
with them"
- "Files and folders can have read (`r`), write (`w`) and execute (`x`) permissions
for the file owner, members of the group associated with the file, and for all users"
- "Executable files can be run by providing the path to the file on the command line"
- "The output of a command can be redirected to a file using `>`, or to another program
using `|`"
- "You can sort text using the `sort` command"
---

The shell is more than a way to
create and work with files and folders;
it's also a powerful way to interact with programs.
Most programs that you are familiar with,
for example Microsoft Word or Mozilla Firefox
are *graphical* in nature, i.e., you use
menus, icons, text boxes, and other graphical elements
to control these programs.

Most fields in scientific computing (including computational biology)
are however dominated by command-line programs.

Many programs have **both** a command-line and a graphical interface.

Running and controlling programs via the command-line rather than a GUI
improves the repeatability and reproducibility of your work,
and allows you to automate them.
In this next part of the lesson,
we'll run a simple command-line program (called `wordfreq`).
Given a text file containing several words,
this program counts the frequency of each word,
and prints the result.

Navigate to the directory `genomics-workshop/running-programs/`,
and view the files there:

~~~
[nelle@login001 running-programs]$ ls
wordfreq     words-1.txt       words-2.txt       words-3.txt       words-4.txt
~~~
{: .bash}

Use the `-l` switch to see a detailed, long list of the files and directories:

~~~
[nelle@login001 running-programs]$ ls -l
~~~
{: .bash}

~~~
total 72
-rwxr--r--  1 nelle  cuuser   695 Jul 26 09:14 wordfreq
-rw-r--r--  1 nelle  cuuser  1389 Jul 20 14:40 words-1.txt
-rw-r--r--  1 nelle  cuuser  2573 Jul 20 14:40 words-2.txt
-rw-r--r--  1 nelle  cuuser  8715 Jul 20 14:41 words-3.txt
-rw-r--r--  1 nelle  cuuser  9319 Jul 20 14:41 words-4.txt
~~~

Among other information, such as the
owner of the files (`nelle`), the "user group" that the files belong to (`cuuser`),
the last accessed time, etc.,
the first column of the output shows you
the **permissions** that different entitites have for each file.

A permission of `-rwxr--r--` means:

* The first column `-` means the object is a regular file, for directories,
this column would hold a `d`.
* The next three columns `rwx` tell us what permission the owner of the file has.
In this case, the owner of the file may **read** (`r`), **write** (`w`),
and **execute** (`x`) the file.
While reading/writing applies to any kind of file,
execution only applies to scripts or compiled programs.
Such files are thusly named **executables**.
* The following three columns `r--` tell us what permission the members of
the user group associated with the file have.
In this case, members of the `cuuser` group may **read** (`r`) the file only.
They may not write to it (change its contents).
* The final three columns `---` tell us what permissions everybody else has.
In this case, users that are not part of the `cuuser` group
may not read or write to the file at all.

We see that we have execute `x` permission on the `wordfreq` program.
To run an executable, you can usually just type in
the path to it:

~~~
<<<<<<< HEAD
$ ./wordfreq
~~~
{: .bash}

~~~
usage: wordfreq [-h] [-j N] files [files ...]
wordfreq: error: the following arguments are required: files
~~~
{: .error}

We see that `wordfreq` is missing a required argument
or input `files`.
Let's examine the "help" for `wordfreq` to understand
this better:

~~~
$ ./wordfreq -h
~~~~
{: .bash}

~~~
usage: wordfreq [-h] [-j N] files [files ...]

positional arguments:
  files       Input files

optional arguments:
  -h, --help  show this help message and exit
  -j N        Number of tasks to use
~~~
{: .output}


Let's try specifying the name of an input file:

~~~
$ ./wordfreq words-1.txt
~~~
{: .bash}


~~~
ashwin@laptop ~/w/g/c/g/d/g/running-programs> ./wordfreq words-1.txt 
6 it
9 is
11 a
2 truth
1 universally
1 acknowledged
8 that
4 single
4 man
5 in
2 possession
11 of
~~~
{: .output}

This time, `wordfreq` works as expected,
printing the frequency of each word in the file `words-1.txt`.

So far, all the commands we have been entering either produce no output
(such as `cd`), or print output to the shell window.
It is possible to *redirect* the ouput of a command
to a file using the redirection operator `>`:
=======
[nelle@login001 running-programs]$ ./wordfreq
~~~
{: .bash}

~~~
usage: wordfreq [-h] [-j N] files [files ...]
wordfreq: error: the following arguments are required: files
~~~
{: .error}


We find that our command doesn't complete successfully and that we receive an *error*.
Running into errors is very common when using the command-line.
A common source of errors, for example, is making spelling mistakes when typing out commands.
But this error is different; the shell is telling us that we are missing a required argument
to the `wordfreq` program called `files`. We can learn more about this by
asking for help on how to use wordfreq correctly:

~~~
[nelle@login001 running-programs]$ ./wordfreq --help
~~~
{: .bash}

~~~
usage: wordfreq [-h] [-j N] files [files ...]

Print word frequency for one or more text files. Removes all punctuation and
converts words to lowercase before counting.

positional arguments:
  files       Input files

optional arguments:
  -h, --help  show this help message and exit
  -j N        Number of tasks to use

~~~
{: .output}

The output may seem cryptic at first, so let's break it down:

~~~
usage: wordfreq [-h] [-j N] files [files ...]
~~~

This line gives us a **lot** of information.
It tells us what arguments may be provided to the `wordfreq` program,
which of them are optional and which are required.

Optional arguments (not required) are shown in square brackets (e.g., `[-j N]`).
The remaining arguments (not in square brackets) are **positional** or **required** arguments.

Here, we have two optional arguments `-h` and `-j`; and one positional argument `files`.

Some arguments like `-j` must be followed by a value (indicated by `N` here).
Other arguments like `-h` do not have a value associated with them.
When a value is of the form `[abc ...]`, it indicates that
it can be a **list** of space-separated values.
Here, the positional argument `files` can be a list of values.

When specifying optional arguments, you must specify both the
name of the argument (e.g., `-j`) and the value after it.
For positional arguments, you only specify the value.

Lastly, the values for positional arguments must be specified in the same order
they appear in the help text above (thus the name *positional*).

The next two lines are a description of what the `wordfreq` program does:

~~~
Print word frequency for one or more text files. Removes all punctuation and
converts words to lowercase before counting.
~~~

And the following lines describe each of the arguments:

~~~
positional arguments:
  files       Input files

optional arguments:
  -h, --help  show this help message and exit
  -j N        Number of tasks to use
~~~

Now that we know exactly how to specify the arguments
to `wordfreq`, let's try again, and this time provide
the value for the positional argument `files`:

~~~
[nelle@login001 running-programs]$ ./wordfreq words-1.txt
~~~
{: .bash}

~~~
1 replied
1 
1 all
1 just
1 agreed
2 by
2 four
1 fine
1 before
1 cried
1 had
1 young
1 day
8 to
.
.
.
~~~
{: .output}

Because `files` can be a **list** of values, let's try with two files:

~~~
[nelle@login001 running-programs]$ ./wordfreq words-1.txt words-2.txt
~~~
{: .bash}
>>>>>>> 8cc801c99574a662ff6875bf89812109618cebeb

~~~
2 
2 all
1 consider
1 agreed
3 four
4 go
1 fine
1 children
5 one
1 certainly
1 just
2 young
2 send
1 should
19 to
1 only
1 consent
.
.
.
~~~
<<<<<<< HEAD
{: .bash}

The above command does not print anything.
This is because the output has been *redirected* to the file `count-words-1.txt`.
Let's examine that file to confirm our output is there:

~~~
$ cat count-words-1.txt 
~~~
{: .bash}

~~~
6 it
9 is
11 a
2 truth
1 universally
1 acknowledged
8 that
4 single
4 man
5 in
2 possession
11 of
1 good
~~~
{: .output}
=======
{: .output}

So far, all the commands we have entered print their output
to the terminal screen.
Sometimes, it's beneficial to store this output somewhere (i.e., in a file).
We can do this easily using the *redirection* operator `>`.
>>>>>>> 8cc801c99574a662ff6875bf89812109618cebeb

~~~
[nelle@login001 running-programs]$ ./wordfreq words-1.txt > count-words-1.txt
~~~
{: .bash}

Above, we *redirect* the output of the command `./wordfreq words-1.txt` to the file `count-words-1.txt`.
That's why we don't see any output.
Look at the file `count-words-1.txt`:

~~~
[nelle@login001 running-programs]$ cat count-words-1.txt 
~~~
{: .bash}

~~~
1 replied
1 
1 all
1 just
1 agreed
2 by
2 four
1 fine
1 before
1 cried
1 had
1 young
1 day
8 to
.
.
.
~~~
{: .output}

One typical application of a program like `wordfreq` is to find out the
most frequently occurring word(s) in a file.
To obtain this information, we can re-order the output of `wordfreq`
such that we get the most common words at the top of the output,
and the least common words at the bottom.

The `sort` command helps us do this reordering:

~~~
[nelle@login001 running-programs]$ sort -n count-words-1.txt
~~~
{: .bash}

~~~
1 
1 about
1 acknowledged
1 agreed
1 all
1 answer
1 are
1 at
1 been
1 before
1 bingley
1 but
1 came
1 chaise
1 considered
1 cried
1 daughters
1 day
1 delighted
.
.
.
5 his
5 in
6 he
6 it
8 that
8 the
8 to
9 is
11 a
11 of
~~~
{: .output}

We can sort in *reverse* mode using `sort -r`:

~~~
[nelle@login001 running-programs]$ sort -n -r count-words-1.txt
~~~
{: .bash}

In the above exercise,
we ran `wordfreq` on our input data, saving the intermediate result to a file;
and then ran `sort` on the file to get the final result.
As it turns out, we don't have to do this.
The shell makes it very convenient for programs to
communicate between themselves.
Using the pipe `|` character,
we can directly send the result of the `wordfreq` program
to the `sort` program:

~~~
[nelle@login001 running-programs]$ ./wordfreq input-1.txt | sort -n -r
~~~
{: .bash}

~~~
11 of
11 a
9 is
8 to
8 the
8 that
6 it
6 he
5 in
5 his
.
.
.
.
1 but
1 bingley
1 before
1 been
1 at
1 are
1 answer
1 all
1 agreed
1 acknowledged
1 about
1 
~~~
{: .output}

The pipe character takes the result of the command on its left,
and redirects it as input to the command on its right.
Thus, we get the final, re-ordered output using a single command:

~~~
11 of
11 a
9 is
8 to
8 the
8 that
6 it
6 he
5 in
5 his
.
.
.
.
1 but
1 bingley
1 before
1 been
1 at
1 are
1 answer
1 all
1 agreed
1 acknowledged
1 about
1 
~~~
{: .output}

> ## Pipes
> 
> We want to write a single command that will print
> out the 3 most frequently occurring words
> in the file `words-1.txt`.
> We know that the following command will print
> the count for all words in reverse-sorted order:
>
> ~~~
> ./wordfreq input-1.txt | sort -n -r
> ~~~
> {: .bash}
>
> What would you add to the above command to
> make it print only the 3 most common words?
>
>
> Hint: you will need to *pipe* the result
> of the above command to another program:
>
> ~~~
> ./wordfreq input-1.txt | sort -n -r | ______
> ~~~
> {: .bash}
>
{: .challenge}

